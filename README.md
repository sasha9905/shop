# Микросервисная система управления интернет-магазином

## Описание проекта

Данный проект представляет собой микросервисную архитектуру для управления интернет-магазином, состоящую из трех независимых микросервисов, взаимодействующих между собой асинхронно через брокер сообщений RabbitMQ. Система реализует полный цикл работы с пользователями, каталогом товаров и заказами.

## Архитектура проекта

Проект состоит из трех микросервисов:

1. **auth_service** (порт 8000) - сервис авторизации и аутентификации
2. **catalog_service** (порт 8001) - сервис управления каталогом товаров
3. **order_service** (порт 8002) - сервис управления заказами

Каждый микросервис имеет собственную базу данных PostgreSQL и работает независимо от других, взаимодействуя через HTTP API и асинхронные сообщения через RabbitMQ.

## Технологический стек

- **Python** - основной язык программирования
- **FastAPI** - веб-фреймворк для создания REST API
- **SQLAlchemy** (асинхронная версия) - ORM для работы с базой данных
- **PostgreSQL** - реляционная база данных
- **RabbitMQ** - брокер сообщений для асинхронного взаимодействия
- **FastStream** - библиотека для работы с RabbitMQ
- **JWT (python-jose)** - для создания и верификации токенов авторизации
- **bcrypt** - для безопасного хеширования паролей
- **Uvicorn** - ASGI сервер для запуска FastAPI приложений
- **Pydantic** - для валидации данных и настроек

## Структура проекта

```
shop/
├── auth_service/          # Микросервис авторизации
│   ├── requirements.txt
│   └── src/
│       ├── main.py
│       ├── config.py
│       ├── api/
│       │   ├── auth_api.py      # API для регистрации, входа и верификации токенов
│       │   └── user_api.py      # API для управления пользователями
│       ├── core/
│       │   ├── dependencies.py  # Зависимости FastAPI (авторизация, БД)
│       │   ├── security.py      # Функции безопасности (JWT, хеширование паролей)
│       │   └── db_dependency.py # Управление подключением к БД
│       ├── models/
│       │   └── users.py         # Модель пользователя
│       ├── schemas/
│       │   ├── user.py          # Pydantic схемы для пользователей
│       │   └── token.py         # Схемы для токенов
│       └── services/
│           ├── auth_service.py  # Бизнес-логика авторизации
│           └── user_service.py  # Бизнес-логика работы с пользователями
│
├── catalog_service/       # Микросервис каталога
│   ├── requirements.txt
│   └── src/
│       ├── main.py
│       ├── config.py
│       ├── api/
│       │   ├── product_api.py   # API для работы с товарами
│       │   └── categories_api.py # API для работы с категориями
│       ├── consumer/
│       │   └── subscriber.py    # Подписчики на события от других сервисов
│       ├── core/
│       │   ├── dependencies.py  # Зависимости (авторизация через auth_service)
│       │   └── security.py      # Верификация токенов через HTTP запросы
│       ├── database/
│       │   └── db_dependency.py # Управление подключением к БД
│       ├── models/
│       │   ├── products.py      # Модель товара
│       │   ├── categories.py    # Модель категории
│       │   └── users.py         # Локальная копия модели пользователя
│       ├── schemas/
│       │   └── DTO.py           # Data Transfer Objects
│       └── services/
│           └── user_service.py  # Синхронизация пользователей
│
└── order_service/         # Микросервис заказов
    ├── requirements.txt
    └── src/
        ├── main.py
        ├── config.py
        ├── api/
        │   └── order_api.py     # API для работы с заказами
        ├── consumer/
        │   ├── user_sub.py      # Подписчик на события пользователей
        │   └── product_sub.py   # Подписчик на события товаров
        ├── core/
        │   ├── dependencies.py  # Зависимости (авторизация, сервисы)
        │   └── security.py      # Верификация токенов
        ├── database/
        │   └── db_dependency.py # Управление подключением к БД
        ├── models/
        │   ├── orders.py        # Модель заказа
        │   ├── order_items.py   # Модель элемента заказа
        │   ├── products.py     # Локальная копия модели товара
        │   └── users.py        # Локальная копия модели пользователя
        ├── repositories/
        │   ├── base_repository.py # Базовый репозиторий
        │   ├── order_repository.py # Репозиторий заказов
        │   └── product_repository.py # Репозиторий товаров
        ├── schemas/
        │   └── DTO.py          # Data Transfer Objects
        └── services/
            ├── order_service.py # Бизнес-логика заказов
            └── user_service.py  # Синхронизация пользователей
```

## Микросервисы

### 1. Auth Service (Сервис авторизации)

**Порт:** 8000  
**Назначение:** Централизованная авторизация и аутентификация пользователей

**Основные функции:**
- Регистрация новых пользователей
- Аутентификация пользователей (логин)
- Генерация и верификация JWT токенов
- Управление пользователями (CRUD операции)
- Управление ролями пользователей (USER, ADMIN)

**Модели данных:**
- `User` - пользователь системы с полями: id (UUID), username, email, password (хешированный), role (USER/ADMIN)

**API методы:**

#### POST `/api/v1/auth/register`
Регистрация нового пользователя в системе.

**Описание:** Создает нового пользователя с указанными данными. Пароль автоматически хешируется с использованием bcrypt. После успешной регистрации отправляет событие `user_created` в RabbitMQ для синхронизации с другими сервисами.

**Параметры:**
- `username` (string) - уникальное имя пользователя
- `email` (string) - email адрес
- `password` (string) - пароль (будет захеширован)

**Ответ:** Данные созданного пользователя (без пароля)

**Бизнес-функция:** Регистрация пользователя

---

#### POST `/api/v1/auth/login`
Аутентификация пользователя и получение JWT токена.

**Описание:** Проверяет учетные данные пользователя и возвращает JWT токен для дальнейшей авторизации в системе.

**Параметры:**
- `username` (string) - имя пользователя
- `password` (string) - пароль

**Ответ:** JWT токен доступа

**Бизнес-функция:** Аутентификация пользователя

---

#### POST `/api/v1/auth/verify`
Верификация JWT токена (используется другими микросервисами).

**Описание:** Проверяет валидность JWT токена и возвращает информацию о пользователе. Используется catalog_service и order_service для проверки авторизации запросов.

**Параметры:**
- `token` (string) - JWT токен для проверки

**Ответ:** 
- `valid` (boolean) - валидность токена
- `user_id` (string) - ID пользователя (если токен валиден)
- `role` (string) - роль пользователя (если токен валиден)
- `username` (string) - имя пользователя (если токен валиден)

**Бизнес-функция:** Верификация токена авторизации

---

#### GET `/api/v1/users/me`
Получение информации о текущем авторизованном пользователе.

**Описание:** Возвращает данные пользователя, который выполнил запрос (определяется по JWT токену).

**Требует авторизации:** Да (любой авторизованный пользователь)

**Ответ:** Данные текущего пользователя

**Бизнес-функция:** Получение профиля пользователя

---

#### GET `/api/v1/users/`
Получение списка всех пользователей.

**Описание:** Возвращает список всех зарегистрированных пользователей в системе.

**Требует авторизации:** Да (только ADMIN)

**Ответ:** Список пользователей

**Бизнес-функция:** Управление пользователями (для администраторов)

---

#### GET `/api/v1/users/{user_id}`
Получение информации о конкретном пользователе по ID.

**Описание:** Возвращает данные пользователя с указанным ID.

**Требует авторизации:** Да (только ADMIN)

**Параметры:**
- `user_id` (string, UUID) - идентификатор пользователя

**Ответ:** Данные пользователя

**Бизнес-функция:** Управление пользователями (для администраторов)

---

#### PUT `/api/v1/users/me`
Обновление данных текущего пользователя.

**Описание:** Позволяет авторизованному пользователю обновить свои данные (username, email). После обновления отправляет событие `user_updated` в RabbitMQ.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Параметры:**
- `username` (string, опционально) - новое имя пользователя
- `email` (string, опционально) - новый email

**Ответ:** Обновленные данные пользователя

**Бизнес-функция:** Редактирование профиля пользователя

---

#### DELETE `/api/v1/users/{user_id}`
Удаление пользователя из системы.

**Описание:** Удаляет пользователя с указанным ID. Доступно только администраторам. После удаления отправляет событие `user_deleted` в RabbitMQ.

**Требует авторизации:** Да (только ADMIN)

**Параметры:**
- `user_id` (string, UUID) - идентификатор пользователя для удаления

**Ответ:** Сообщение об успешном удалении

**Бизнес-функция:** Управление пользователями (для администраторов)

---

**События RabbitMQ:**
- `user_created` (FANOUT exchange) - публикуется при создании нового пользователя
- `user_updated` (FANOUT exchange) - публикуется при обновлении пользователя
- `user_deleted` (FANOUT exchange) - публикуется при удалении пользователя

---

### 2. Catalog Service (Сервис каталога)

**Порт:** 8001  
**Назначение:** Управление каталогом товаров и категориями

**Основные функции:**
- Управление категориями товаров (неограниченная вложенность)
- Управление товарами
- Синхронизация данных о пользователях из auth_service
- Публикация событий о создании товаров для order_service

**Модели данных:**
- `Category` - категория товаров с полями: id, name, parent_id (ссылка на родительскую категорию), level (уровень вложенности, 0 для корня)
- `Product` - товар с полями: id, name, price, storage_quantity (количество на складе), category_id (ссылка на категорию)
- `User` - локальная копия пользователя для синхронизации

**API методы:**

#### POST `/api/v1/category`
Создание новой категории товаров.

**Описание:** Создает новую категорию в каталоге. Поддерживает неограниченную вложенность через указание parent_id. Уровень вложенности (level) рассчитывается автоматически на основе родительской категории.

**Требует авторизации:** Да (только ADMIN)

**Параметры:**
- `name` (string) - название категории
- `parent_id` (integer, опционально) - ID родительской категории (0 или null для корневой категории)

**Ответ:** Созданная категория

**Бизнес-функция:** Управление каталогом товаров

---

#### GET `/api/v1/categories`
Получение списка всех категорий.

**Описание:** Возвращает полный список всех категорий в каталоге с их иерархией.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Ответ:** Список всех категорий

**Бизнес-функция:** Просмотр каталога товаров

---

#### POST `/api/v1/product`
Создание нового товара в каталоге.

**Описание:** Создает новый товар и привязывает его к указанной категории. После создания отправляет событие `product.created` в очередь RabbitMQ для синхронизации с order_service.

**Требует авторизации:** Да (только ADMIN)

**Параметры:**
- `name` (string) - название товара
- `price` (integer) - цена товара
- `quantity` (integer) - количество товара на складе
- `category_id` (integer) - ID категории, к которой относится товар

**Ответ:** Созданный товар

**Бизнес-функция:** Управление каталогом товаров

---

#### GET `/api/v1/products`
Получение списка всех товаров.

**Описание:** Возвращает полный список всех товаров в каталоге.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Ответ:** Список всех товаров

**Бизнес-функция:** Просмотр каталога товаров

---

#### GET `/api/v1/products_with_category`
Получение товаров по категории.

**Описание:** Возвращает список товаров, принадлежащих указанной категории.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Параметры:**
- `id` (integer, query parameter) - ID категории

**Ответ:** Список товаров указанной категории

**Бизнес-функция:** Просмотр каталога товаров

---

**Подписки на события RabbitMQ:**
- `user_created` - синхронизация нового пользователя
- `user_updated` - обновление данных пользователя
- `user_deleted` - удаление пользователя

**Публикация событий RabbitMQ:**
- `product.created` (queue) - публикуется при создании нового товара

---

### 3. Order Service (Сервис заказов)

**Порт:** 8002  
**Назначение:** Управление заказами пользователей

**Основные функции:**
- Создание заказов авторизованными пользователями
- Просмотр заказов
- Обновление элементов заказа
- Синхронизация данных о пользователях и товарах из других сервисов

**Модели данных:**
- `Order` - заказ с полями: id, user_id (ссылка на пользователя), total_quantity (общее количество товаров в заказе), created_at (время создания)
- `OrderItem` - элемент заказа с полями: id, order_id (ссылка на заказ), product_id (ссылка на товар), product_quantity (количество товара)
- `Product` - локальная копия товара для синхронизации
- `User` - локальная копия пользователя для синхронизации

**API методы:**

#### POST `/order`
Создание нового заказа.

**Описание:** Создает новый заказ для авторизованного пользователя. Заказ может содержать несколько товаров с указанием количества каждого. Проверяет наличие товаров в локальной базе данных (синхронизированной с catalog_service).

**Требует авторизации:** Да (любой авторизованный пользователь)

**Параметры:**
- `user_id` (string, UUID) - ID пользователя, создающего заказ
- `items` (array) - массив элементов заказа, каждый содержит:
  - `product_id` (integer) - ID товара
  - `quantity` (integer) - количество товара

**Ответ:** Созданный заказ с полной информацией о товарах

**Бизнес-функция:** Создание заказа

---

#### GET `/order/{order_id}`
Получение информации о конкретном заказе.

**Описание:** Возвращает полную информацию о заказе, включая данные о пользователе и всех товарах в заказе.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Параметры:**
- `order_id` (integer) - идентификатор заказа

**Ответ:** Данные заказа с информацией о товарах

**Бизнес-функция:** Просмотр заказа

---

#### PUT `/update_order/{order_id}`
Обновление элемента заказа.

**Описание:** Позволяет изменить количество товара в существующем заказе.

**Требует авторизации:** Да (любой авторизованный пользователь)

**Параметры:**
- `order_id` (integer, path parameter) - ID заказа
- `order_item_id` (integer) - ID элемента заказа для обновления
- `quantity` (integer) - новое количество товара

**Ответ:** Обновленный элемент заказа

**Бизнес-функция:** Редактирование заказа

---

**Подписки на события RabbitMQ:**
- `user_created` - синхронизация нового пользователя
- `user_updated` - обновление данных пользователя
- `user_deleted` - удаление пользователя
- `product.created` - синхронизация нового товара

---

## Взаимодействие между микросервисами

### Асинхронное взаимодействие через RabbitMQ

Микросервисы взаимодействуют асинхронно через брокер сообщений RabbitMQ, используя следующие паттерны:

1. **FANOUT Exchange** - для широковещательной рассылки событий:
   - `user_created` - создание пользователя
   - `user_updated` - обновление пользователя
   - `user_deleted` - удаление пользователя

2. **Queue** - для точечной доставки сообщений:
   - `product.created` - создание товара (от catalog_service к order_service)

### Синхронное взаимодействие через HTTP

Для верификации JWT токенов catalog_service и order_service делают HTTP запросы к auth_service:

- `POST http://localhost:8000/api/v1/auth/verify` - проверка валидности токена

### Схема взаимодействия

```
┌─────────────────┐
│  Auth Service    │
│   (порт 8000)    │
└────────┬─────────┘
         │
         │ HTTP (верификация токенов)
         │
         ▼
┌─────────────────┐         ┌─────────────────┐
│Catalog Service  │◄────────┤  Order Service  │
│  (порт 8001)    │         │   (порт 8002)    │
└────────┬────────┘         └─────────────────┘
         │
         │
         ▼
    ┌─────────┐
    │RabbitMQ │
    └─────────┘
         │
         │ События:
         │ - user_created
         │ - user_updated
         │ - user_deleted
         │ - product.created
         │
         ▼
    Синхронизация данных
    между сервисами
```

## Безопасность

### Авторизация через JWT

Все API методы (кроме регистрации и входа) требуют авторизации через JWT токен. Токен передается в заголовке запроса:

```
Authorization: Bearer <token>
```

### Хранение паролей

Пароли пользователей хранятся в базе данных в захешированном виде с использованием алгоритма **bcrypt**. Это обеспечивает защиту от утечек данных - даже при компрометации базы данных злоумышленник не сможет восстановить исходные пароли.

### Роли пользователей

Система поддерживает две роли:
- **USER** - обычный пользователь (может просматривать каталог, создавать и просматривать свои заказы)
- **ADMIN** - администратор (имеет полный доступ, включая управление пользователями, категориями и товарами)

### Проверка авторизации

1. **Auth Service** - проверяет токены локально, используя секретный ключ JWT
2. **Catalog Service и Order Service** - проверяют токены через HTTP запрос к auth_service, что обеспечивает централизованную валидацию

## Протоколы обмена данными

Все взаимодействие между клиентом и сервисами, а также между сервисами происходит по протоколу **HTTP** (или **HTTPS** в production окружении).

- REST API endpoints используют HTTP методы (GET, POST, PUT, DELETE)
- Внутреннее взаимодействие между сервисами для верификации токенов также использует HTTP
- Асинхронное взаимодействие через RabbitMQ использует протокол AMQP поверх TCP

## Базы данных

Каждый микросервис имеет собственную базу данных PostgreSQL:

- **auth_service** - база данных для пользователей и их учетных данных
- **catalog_service** - база данных для категорий и товаров, а также локальная копия пользователей
- **order_service** - база данных для заказов, а также локальные копии пользователей и товаров

Такая архитектура обеспечивает:
- Независимость сервисов
- Масштабируемость (каждый сервис можно масштабировать независимо)
- Изоляцию данных

## Установка и запуск

### Требования

- Python 3.10+
- PostgreSQL (3 экземпляра или 3 базы данных)
- RabbitMQ
- Docker и Docker Compose (опционально, для контейнеризации)

### Настройка окружения

Для каждого микросервиса необходимо создать файл `.env` в корне директории сервиса со следующим содержимым:

**auth_service/.env:**
```env
# Database
db_name=auth_db
db_user=postgres
db_password=your_password
db_host=localhost
db_port=5432
db_echo=False

# JWT
jwt_secret_key=your_secret_key_here
jwt_algorithm=HS256
access_token_expire_minutes=30

# RabbitMQ
rabbitmq_host=localhost
rabbitmq_port=5672
rabbitmq_user=guest
rabbitmq_password=guest
```

**catalog_service/.env:**
```env
# Database
db_name=catalog_db
db_user=postgres
db_password=your_password
db_host=localhost
db_port=5432
db_echo=False

# JWT (должен совпадать с auth_service)
jwt_secret_key=your_secret_key_here
jwt_algorithm=HS256
access_token_expire_minutes=30

# RabbitMQ
rabbitmq_host=localhost
rabbitmq_port=5672
rabbitmq_user=guest
rabbitmq_password=guest
```

**order_service/.env:**
```env
# Database
db_name=order_db
db_user=postgres
db_password=your_password
db_host=localhost
db_port=5432
db_echo=False

# JWT (должен совпадать с auth_service)
jwt_secret_key=your_secret_key_here
jwt_algorithm=HS256
access_token_expire_minutes=30

# RabbitMQ
rabbitmq_host=localhost
rabbitmq_port=5672
rabbitmq_user=guest
rabbitmq_password=guest
```

### Установка зависимостей

Для каждого сервиса:

```bash
# Auth Service
cd auth_service
python -m venv venv
source venv/bin/activate  # На Windows: venv\Scripts\activate
pip install -r requirements.txt

# Catalog Service
cd ../catalog_service
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# Order Service
cd ../order_service
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

### Запуск сервисов

Запустите каждый сервис в отдельном терминале:

```bash
# Терминал 1 - Auth Service
cd auth_service/src
python main.py

# Терминал 2 - Catalog Service
cd catalog_service/src
python main.py

# Терминал 3 - Order Service
cd order_service/src
python main.py
```

Или используйте uvicorn напрямую:

```bash
# Auth Service
cd auth_service/src
uvicorn main:app --port 8000

# Catalog Service
cd catalog_service/src
uvicorn main:app --port 8001

# Order Service
cd order_service/src
uvicorn main:app --port 8002
```

## Использование API

### Примеры запросов

#### 1. Регистрация пользователя

```bash
curl -X POST "http://localhost:8000/api/v1/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "securepassword123"
  }'
```

#### 2. Вход в систему

```bash
curl -X POST "http://localhost:8000/api/v1/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "securepassword123"
  }'
```

Ответ содержит JWT токен:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer"
}
```

#### 3. Создание категории (требует авторизации ADMIN)

```bash
curl -X POST "http://localhost:8001/api/v1/category" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "name": "Электроника",
    "parent_id": 0
  }'
```

#### 4. Создание товара (требует авторизации ADMIN)

```bash
curl -X POST "http://localhost:8001/api/v1/product" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "name": "Смартфон",
    "price": 30000,
    "quantity": 50,
    "category_id": 1
  }'
```

#### 5. Просмотр товаров (требует авторизации)

```bash
curl -X GET "http://localhost:8001/api/v1/products" \
  -H "Authorization: Bearer <token>"
```

#### 6. Создание заказа (требует авторизации)

```bash
curl -X POST "http://localhost:8002/order" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "user_id": "123e4567-e89b-12d3-a456-426614174000",
    "items": [
      {
        "product_id": 1,
        "quantity": 2
      },
      {
        "product_id": 2,
        "quantity": 1
      }
    ]
  }'
```

## Бизнес-функции приложения

API методы реализуют следующие бизнес-функции:

1. **Управление пользователями**
   - Регистрация новых пользователей (`POST /api/v1/auth/register`)
   - Аутентификация пользователей (`POST /api/v1/auth/login`)
   - Просмотр и редактирование профиля (`GET /api/v1/users/me`, `PUT /api/v1/users/me`)
   - Административное управление пользователями (`GET /api/v1/users/`, `GET /api/v1/users/{id}`, `DELETE /api/v1/users/{id}`)

2. **Управление каталогом товаров**
   - Создание и просмотр категорий (`POST /api/v1/category`, `GET /api/v1/categories`)
   - Создание и просмотр товаров (`POST /api/v1/product`, `GET /api/v1/products`, `GET /api/v1/products_with_category`)

3. **Управление заказами**
   - Создание заказов (`POST /order`)
   - Просмотр заказов (`GET /order/{order_id}`)
   - Редактирование заказов (`PUT /update_order/{order_id}`)

4. **Безопасность и авторизация**
   - Верификация токенов (`POST /api/v1/auth/verify`)

## Особенности реализации

### Принципы ООП

Проект следует принципам объектно-ориентированного программирования:
- Инкапсуляция бизнес-логики в сервисных классах
- Использование моделей данных (SQLAlchemy ORM)
- Разделение ответственности между слоями (API, Service, Repository, Model)

### Чистый и читаемый код

- Четкая структура проекта с разделением по слоям
- Использование type hints для улучшения читаемости
- Документация в коде (docstrings)
- Логирование важных операций
- Обработка ошибок с понятными сообщениями

### Асинхронность

- Все операции с базой данных выполняются асинхронно (async/await)
- Асинхронное взаимодействие через RabbitMQ
- Асинхронные HTTP запросы для верификации токенов

## Мониторинг и логирование

Все сервисы используют стандартный модуль `logging` Python для записи важных событий:
- Создание, обновление и удаление пользователей
- Создание товаров
- Создание заказов
- Ошибки авторизации
- Синхронизация данных между сервисами

## Health Check

Каждый сервис предоставляет endpoint для проверки работоспособности:

- Auth Service: `GET http://localhost:8000/`
- Catalog Service: `GET http://localhost:8001/`
- Order Service: `GET http://localhost:8002/` (через основной router)

Ответ: `{"status": "ok"}`

## Дальнейшее развитие

Возможные улучшения проекта:
- Добавление Docker Compose для удобного развертывания
- Реализация HTTPS для production окружения
- Добавление rate limiting для защиты от злоупотреблений
- Реализация пагинации для списков товаров и заказов
- Добавление фильтрации и сортировки
- Реализация полнотекстового поиска товаров
- Добавление метрик и мониторинга (Prometheus, Grafana)
- Реализация кэширования (Redis)
- Добавление unit и integration тестов

## Лицензия

Проект создан в учебных целях.

